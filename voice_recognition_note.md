# 音声入力機能を実装したら、世界史の勉強が「詠唱」になった話

先日の記事で「タイピングだるい」「選択肢問題は甘え」という話をしましたが、ついにやってやりましたよ。
**「音声入力機能」、実装完了です。**

これね、実際に使ってみると完全に**「詠唱」**なんですよ。
画面に向かって「ナポレオン！」とか「ワシントン会議！」とか叫ぶの。周りから見たらヤバい人ですが、学習効果は爆上がり（な気がする）。

今回は、この機能をどうやって実装したのか、技術的な裏側をちょっとだけ公開しちゃいます。
プログラミング初心者の方でも「へぇ〜」ってなるように書いたつもりなので、ぜひ読んでいってくださいな⭐︎

---

## なぜ「音声入力」なのか？（そこに愛はあるんか？）

ぶっちゃけ、4択クイズを作るだけなら秒で終わるんです。
でもね、現場で生徒を見ていて一番思うのが、**「わかった気になっている」**ことの多さ。

選択肢があれば正解できる。でも、何もないところから用語が出てこない。
これじゃあ記述模試や論述で戦えないわけです。

かといって、スマホで毎回「マルクス＝アウレリウス＝アントニヌス」とか「王侯将相いずくんぞ種あらんや」とかフリック入力するのは拷問に近い。

そこで**「声」**ですよ。

## Step 1: ブラウザに「答え」を耳打ちする（Grammar Injection）

Webブラウザには標準で「Web Speech API」という音声認識機能がついています。これを使えば簡単に声を聞き取れる…と思いきや、罠があります。

世界史の用語って、一般的じゃない言葉のオンパレードなんですよ。
例えば「墾田永年私財法」なんて、普通の会話で言いませんよね？
普通に認識させると「今電王ねん取材法」とか謎の変換をしてきやがります。使えねぇ…。

そこで登場するのが、**「Grammar Injection（文法インジェクション）」**という魔法。
ブラウザに対して、「これからこの単語が来る確率が高いぞ！」と事前に教えてあげる技術です。

```javascript
// 答えが「ナポレオン」の場合
const grammar = '#JSGF V1.0; grammar answer; public <answer> = ナポレオン | napoleon ;';

// 重み付けを「10倍」にして耳打ちする
speechRecognitionList.addFromString(grammar, 10);
```

こうすることで、多少滑舌が悪くても、ブラウザくんが「あ、はいはいナポレオンですね！」と空気を読んでくれるようになります。
えっ、それってズルじゃないかって？
いいえ、**「親切設計」**です（キリッ）。

## Step 2: 漢字変換の壁をハックする（Katakana Fallback）

しかし、これで万事解決とはいきませんでした。
最大の敵、**「漢字変換」**です。

例えば正解が「**始皇帝**」だとします。
ユーザーが完璧な発音で「しこうてい」と言いました。
でもブラウザくんが気を利かせて「**施工程**」と漢字変換して返してくることがあるんです。

アプリ側：「正解は『始皇帝』です。『施工程』？ 不正解！」
ユーザー：「はぁ！？ 合ってるし！！」

これではストレスで端末が壁に投げつけられてしまいます。
そこで実装したのが、**「サーバーサイド・カタカナ・フォールバック」**。必殺技みたいでしょ。

1. アプリ側で正解（漢字）と一致しない場合、諦めずにサーバーにそのテキストを送る。
2. サーバー側では Pythonライブラリ `pykakasi` を使って、そのテキストを無理やりカタカナに戻す。
   - 「施工程」→「シコウテイ」
3. そのカタカナと、正解データの「読み仮名」を比較する。
   - 正解の読み：「シコウテイ」
   - **一致！ 正解！**

```python
# サーバー側の Python コード（イメージ）
import pykakasi

kks = pykakasi.kakasi()

def to_katakana(text):
    result = kks.convert(text)
    # 全てをカタカナに変換して結合
    return "".join([item['kana'] for item in result])
```

この「二段構え」の判定ロジックにより、**「漢字は間違ってるけど、読み方は合ってるからヨシ！」**という、人間の採点官のような柔軟さを手に入れました。

## Step 3: 少しのミスは許してあげる（Fuzzy Matching）

人間だもの、噛むことだってあります。
「コンスタンティノープル」とか、一息で言う自信あります？

そこで、厳密な一致だけでなく、**「レーベンシュタイン距離」**というアルゴリズムを使って、「おしい！」判定も入れています。
文字数の30%くらいまでの違いなら、「もしかして：コンスタンティノープル？」と優しく聞き返してくれます。

---

## Step 4: 「複数回答」の罠を攻略する（AND/OR Logic）

世界史には「別名」や「セットで覚える用語」が無限にあります。
これをAI（プログラム）に判定させるのが地味に大変でした。

### パターンA：どっちでもいいよ（OR条件）
例えば、「**オクタヴィアヌス**」と言っても「**アウグストゥス**」と言っても正解にしたい場合。
CSVデータにはカンマ区切りで `オクタヴィアヌス,アウグストゥス` と登録しています。

プログラムはこれを「カンマだ！どれか一つ合ってればOKね！」と解釈し、どちらを叫んでも「正解！」ポーズをしてくれます。

### パターンB：全部言わなきゃダメ、でも順番は自由（AND条件）
厄介なのがこっち。
「**ヤルタ・ポツダム**」のように、会議名を2つ答える問題。
データはスラッシュ区切りで `ヤルタ会談/ポツダム会談` となっています。

これを「ヤルタ会談…あとなんだっけ…ポツダム会談！」と叫んだ場合、一つの文章として認識されます。
単純な一致判定だと、「ヤルタ会談ポツダム会談」という長い単語と一致するか調べることになり、間に「えーと」とかが入ると即死します。

そこで実装したのが、**「必殺・順不同の部分一致判定」**。

1. 正解データを `/` で分割する（[ヤルタ会談, ポツダム会談]）。
2. ユーザーの音声の中に「ヤルタ会談」が含まれているか？ → OK
3. ユーザーの音声の中に「ポツダム会談」も含まれているか？ → OK
4. **全パーツ揃った！ 正解！**

これにより、「ポツダムと…ヤルタ！」みたいに逆順で言っても正解になります。
柔軟性がすごい。もはや人間の耳より賢いのでは？

---

## 今後の課題：漢字が書けなくなる問題

超便利な音声入力。

しかーーーし！

**「あれ、この単語、漢字でどう書くんだっけ？」**

音声入力は楽ですが、「書く」というプロセスが抜ける分、漢字の定着率が怪しくなるリスクがあります。
「王羲之」とか「羈縻政策」とか、面倒な漢字が多いですからね。

なので、次に実装したいのは**「書き取り確認モード」**。
音声でサクサク進めつつ、間違えやすい漢字の単語だけは「じゃあこれ、書いてみて？」と不意打ちで手書きを要求してくる機能。
急にスパルタかよ。

「声で即答」＋「手で定着」。
このハイブリッドこそが最強の学習法だと信じています。

## 結論：爆速でアウトプットできる快感

こうして完成した音声入力モード。
実際にやってみると、問題を読んでから回答するまでのサイクルが圧倒的に速い。
そして何より、**声を出すことで記憶の定着が違う（気がする）**。

「カノッサの屈辱！」
「神の見えざる手！」
「サンバルテルミの虐殺！」

深夜に部屋で一人、世界史用語を連呼している姿は完全に不審者ですが、記憶定着、教養のためなら安いものです。

これからも「甘やかさないけど、使いやすい」教材アプリを目指して改良を続けていきます。
現場からは以上です。
