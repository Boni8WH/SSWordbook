{% extends "base.html" %}

{% block content %}
<div class="container-fluid p-0" style="height: calc(100vh - 56px); display: flex; flex-direction: column;">
    <!-- Quiz Header / Question Area -->
    <div class="p-3 shadow-sm"
        style="flex-shrink: 0; z-index: 1000; background-color: #ffffff !important; color: #212529 !important; border-bottom: 1px solid #dee2e6;">
        <div class="container d-flex justify-content-between align-items-center">
            <div style="flex: 1;">
                <span class="badge bg-secondary mb-1" id="progressBadge">Question 1</span>
                <h4 id="questionText" class="mb-0 fw-bold">Loading...</h4>
                <div id="explanationText" class="mt-2 text-danger fw-bold" style="display: none;"></div>
            </div>
            <div class="text-end ms-3">
                <a href="{{ url_for('map_quiz_index') }}" class="btn btn-sm btn-outline-secondary">終了</a>
            </div>
        </div>
    </div>

    <!-- Map Area -->
    <div class="position-relative flex-grow-1 bg-secondary overflow-hidden" id="gameArea"
        style="cursor: grab; touch-action: none;">
        <div id="mapWrapper" style="transform-origin: 0 0; position: absolute; top: 0; left: 0;">
            <img id="gameMapImage" src="" style="display: block; max-width: none;" draggable="false">
            <div id="gamePinsContainer"></div>
        </div>

        <!-- Zoom Controls -->
        <div class="position-absolute bottom-0 end-0 mb-4 me-3 d-flex flex-column gap-2" style="z-index: 500;">
            <button class="btn btn-light shadow rounded-circle p-0 d-flex align-items-center justify-content-center"
                style="width: 40px; height: 40px;" onclick="zoomMap(1.2)" title="拡大">
                <i class="fas fa-plus"></i>
            </button>
            <button class="btn btn-light shadow rounded-circle p-0 d-flex align-items-center justify-content-center"
                style="width: 40px; height: 40px;" onclick="zoomMap(0.8)" title="縮小">
                <i class="fas fa-minus"></i>
            </button>
        </div>

        <!-- Next Button Overlay -->
        <div id="nextButtonContainer" class="position-absolute bottom-0 start-50 translate-middle-x mb-5"
            style="display: none; z-index: 9999; padding-bottom: 20px;">
            <button class="btn btn-lg btn-primary rounded-pill px-5 shadow" onclick="nextQuestion()"
                style="border: 2px solid #fff;">
                次の問題へ <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>
</div>

<script>
    // Game State (Renamed to prevent collision with script.js)
    const MAP_ID = {{ map_id }};
    let mqQuizData = null;
    let mqQuestions = []; // List of problems
    let mqCurrentIndex = 0;
    let mqCurrentQuestion = null;
    // let showLabels = false; // Removed toggle logic

    // Lock for multi-click prevention
    let mqIsAnswered = false;

    // Result Tracking
    let mqCorrectCount = 0;
    let mqIncorrectQuestions = []; // objects { question, correctName, explanation }

    // Zoom/Pan State (Simple implementation)
    let scale = 1;
    let panning = false;
    let pointX = 0;
    let pointY = 0;
    let startX = 0;
    let startY = 0;

    const gameArea = document.getElementById('gameArea');
    const mapWrapper = document.getElementById('mapWrapper');

    document.addEventListener('DOMContentLoaded', function () {
        initGame();
        initPanZoom();
    });

    async function initGame() {
        try {
            console.log("Fetching quiz data for map " + MAP_ID);
            // Get difficulty from URL
            const urlParams = new URLSearchParams(window.location.search);
            const difficulty = urlParams.get('difficulty');
            let apiUrl = `/api/map_quiz/map/${MAP_ID}/play_data`;
            if (difficulty) {
                apiUrl += `?difficulty=${difficulty}`;
            }

            const response = await fetch(apiUrl);
            const data = await response.json();
            console.log("Quiz Data:", data);

            if (data.status === 'error') throw new Error(data.message);

            mqQuizData = data;

            // Set Map Image
            document.getElementById('gameMapImage').src = `/serve_map_image/${data.map.filename}`;
            document.getElementById('gameMapImage').onload = () => {
                fitMapToScreen();
            };

            // Render Pins
            renderPins();

            // Prepare Questions (Shuffle)
            mqQuestions = shuffle(data.problems);

            if (mqQuestions.length === 0) {
                document.getElementById('questionText').innerText = '問題がありません';
            } else {
                showQuestion(0);
            }

        } catch (e) {
            alert('ロードエラー: ' + e.message);
        }
    }

    function renderPins() {
        const container = document.getElementById('gamePinsContainer');
        container.innerHTML = '';

        mqQuizData.locations.forEach(loc => {
            const pinBtn = document.createElement('div');
            pinBtn.className = 'game-pin';
            pinBtn.id = `pin-${loc.id}`;
            pinBtn.style.position = 'absolute';
            pinBtn.style.left = `${loc.x}%`;
            pinBtn.style.top = `${loc.y}%`;
            // Wrapper 0 size, no transform on wrapper
            pinBtn.style.width = '0';
            pinBtn.style.height = '0';
            pinBtn.style.overflow = 'visible';
            pinBtn.style.cursor = 'pointer';
            pinBtn.onclick = (e) => onPinClick(e, loc.id);

            // Icon: anchor bottom-center to wrapper (0,0)
            const iconHtml = `<i class="fas fa-map-marker-alt text-danger fa-lg" style="position: absolute; left: 0; top: 0; transform: translate(-50%, -100%); filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); transition: all 0.2s;"></i>`;

            // Label (Only if name is not empty)
            let labelHtml = '';
            if (loc.name && loc.name.trim() !== "") {
                // Labels hidden by default
                labelHtml = `<div class="pin-label badge bg-light text-dark border shadow-sm" id="label-${loc.id}" style="position: absolute; left: 15px; top: -35px; font-size: 14px; white-space: nowrap; display: none;">${loc.name}</div>`;
            }

            pinBtn.innerHTML = iconHtml + labelHtml;
            container.appendChild(pinBtn);
        });
    }

    function showQuestion(index) {
        mqCurrentIndex = index;
        mqCurrentQuestion = mqQuestions[index];
        mqIsAnswered = false; // Reset lock

        document.getElementById('progressBadge').innerText = `Q ${index + 1} / ${mqQuestions.length}`;

        // Debug/Fallback for empty question
        let qText = mqCurrentQuestion.question;
        if (!qText) {
            console.warn("Question text is empty for ID:", mqCurrentQuestion.id);
            qText = "(問題文が読み込めませんでした)";
        }

        const qTextEl = document.getElementById('questionText');
        qTextEl.innerText = qText;

        // Force text visibility style if needed
        qTextEl.style.color = '#212529'; // Ensure dark on white

        document.getElementById('explanationText').style.display = 'none';
        document.getElementById('nextButtonContainer').style.display = 'none';

        // Reset Pin Styles
        document.querySelectorAll('.game-pin i').forEach(icon => {
            icon.className = 'fas fa-map-marker-alt text-danger fa-lg';
        });

        document.getElementById('gameArea').classList.remove('disable-clicks');

        // Reset Map View
        fitMapToScreen();
    }

    function onPinClick(e, locId) {
        e.stopPropagation();
        if (!mqCurrentQuestion) return;
        if (mqIsAnswered) return; // Prevent multi click

        mqIsAnswered = true; // Lock

        // Check Answer
        const isCorrect = (locId === mqCurrentQuestion.location_id);
        const correctLocId = mqCurrentQuestion.location_id;
        const correctLoc = mqQuizData.locations.find(l => l.id === correctLocId);

        // Visual Feedback
        // Show Correct Label
        const correctLabel = document.getElementById(`label-${correctLocId}`);
        if (correctLabel) {
            correctLabel.style.display = 'block';
        }

        if (isCorrect) {
            clickedPin.className = 'fas fa-map-marker-alt text-success fa-3x'; // Green & Bigger
            playAudio('correct');
            mqCorrectCount++;
        } else {
            clickedPin.className = 'fas fa-map-marker-alt text-secondary fa-lg'; // Grey
            correctPin.className = 'fas fa-map-marker-alt text-success fa-3x'; // Show correct one
            correctPin.classList.add('fa-bounce');
            playAudio('wrong');

            // Find clicked location name for feedback
            const clickedLoc = mqQuizData.locations.find(l => l.id === locId);
            const clickedName = clickedLoc ? clickedLoc.name : "不明な地点";

            // Record incorrect answer
            mqIncorrectQuestions.push({
                question: mqCurrentQuestion.question || "(問題文なし)",
                correctName: correctLoc.name || "",
                explanation: mqCurrentQuestion.explanation || ""
            });
        }

        // Show Explanation
        const explain = document.getElementById('explanationText');

        let feedbackHtml = "";
        let explanationContent = mqCurrentQuestion.explanation || "";

        if (isCorrect) {
            feedbackHtml = `<i class="fas fa-check-circle"></i> 正解！ ${explanationContent}`;
        } else {
            const clickedLoc = mqQuizData.locations.find(l => l.id === locId);
            const clickedName = clickedLoc ? clickedLoc.name : "不明な地点";

            // If location name is empty, don't show "Correct is XX"
            if (correctLoc.name && correctLoc.name.trim() !== "") {
                feedbackHtml = `<div class="mb-1"><i class="fas fa-times-circle"></i> 不正解... <span class="fw-bold text-success">正解は「${correctLoc.name}」</span>です。</div>`;
                feedbackHtml += `<div class="mb-2 small text-muted">あなたが選択したのは「${clickedName}」です。</div>`;
                feedbackHtml += explanationContent;
            } else {
                feedbackHtml = `<i class="fas fa-times-circle"></i> 不正解... <br>${explanationContent}`;
            }
        }

        explain.innerHTML = feedbackHtml;
        explain.style.display = 'block';

        // Auto-focus Correct Pin if off-screen
        ensurePinVisible(correctLocId);

        // Show Next Button
        document.getElementById('nextButtonContainer').style.display = 'block';
    }

    function ensurePinVisible(locId) {
        const loc = mqQuizData.locations.find(l => l.id === locId);
        if (!loc) return;

        const container = document.getElementById('gameArea');
        const img = document.getElementById('gameMapImage');

        const containerW = container.clientWidth;
        const containerH = container.clientHeight;
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;

        // Current Pin Screen Coordinates
        // loc.x/y are percentages (0-100)
        const pinImgX = (loc.x / 100) * imgW;
        const pinImgY = (loc.y / 100) * imgH;

        const screenX = pointX + (pinImgX * scale);
        const screenY = pointY + (pinImgY * scale);

        const padding = 60; // Margin from edge

        // Check if visible
        const isVisible = (
            screenX >= padding &&
            screenX <= (containerW - padding) &&
            screenY >= padding &&
            screenY <= (containerH - padding)
        );

        if (!isVisible) {
            // Auto Focus Logic
            // If scale is too high, zoom out for context
            if (scale > 0.5) {
                scale = 0.5;
            } else if (scale < 0.5) {
                // If too zoomed out (unlikely to be invisible but possible), zoom in a bit
                scale = Math.max(scale, 1.0);
            }

            // Target: Center of container
            const targetX = containerW / 2;
            const targetY = containerH / 2;

            // Calculate new pointX/Y
            // targetX = newPointX + (pinImgX * scale)
            pointX = targetX - (pinImgX * scale);
            pointY = targetY - (pinImgY * scale);

            // Add transition for smooth slide
            mapWrapper.style.transition = "transform 0.5s ease-out";
            setTransform();

            // Step 2: After a pause, zoom out to show full map (if we zoomed/panned)
            setTimeout(() => {
                const targetState = calculateFitState();
                if (!targetState) {
                    // Cleanup if calc failed
                    mapWrapper.style.transition = "";
                    return;
                }

                // Slow transition for zoom out
                mapWrapper.style.transition = "transform 3.0s ease-in-out";

                scale = targetState.scale;
                pointX = targetState.pointX;
                pointY = targetState.pointY;

                setTransform();

                // Cleanup transition
                setTimeout(() => {
                    mapWrapper.style.transition = "";
                }, 3000);

            }, 800); // Wait 800ms before starting zoom out
        }
    }

    function nextQuestion() {
        if (mqCurrentIndex < mqQuestions.length - 1) {
            showQuestion(mqCurrentIndex + 1);
        } else {
            showResult();
        }
    }

    function showResult() {
        const total = mqQuestions.length;
        const correct = mqCorrectCount;
        const percentage = total === 0 ? 0 : Math.round((correct / total) * 100);

        document.getElementById('resultScore').innerText = correct;
        document.getElementById('resultTotal').innerText = total;
        document.getElementById('resultPercentage').innerText = `正解率: ${percentage}%`;

        // Message & Icon Logic
        const msgEl = document.getElementById('resultMessage');
        const iconEl = document.getElementById('resultIcon');

        iconEl.style.display = 'none';

        if (percentage === 100) {
            msgEl.innerText = "Perfect!! 素晴らしい！";
            msgEl.className = "fw-bold text-warning";
            iconEl.className = "fas fa-crown fa-4x text-warning mb-3";
            iconEl.style.display = 'inline-block';
            // Start confetti here if implemented
        } else if (percentage >= 80) {
            msgEl.innerText = "Great Job! あと少し！";
            msgEl.className = "fw-bold text-primary";
            iconEl.className = "fas fa-star fa-4x text-primary mb-3";
            iconEl.style.display = 'inline-block';
        } else if (percentage >= 60) {
            msgEl.innerText = "Good! その調子！";
            msgEl.className = "fw-bold text-success";
        } else {
            msgEl.innerText = "Fight! 次は頑張ろう";
            msgEl.className = "fw-bold text-secondary";
        }

        const wrongList = document.getElementById('wrongAnswersList');
        const wrongSection = document.getElementById('wrongAnswersSection');

        wrongList.innerHTML = '';

        if (mqIncorrectQuestions.length > 0) {
            mqIncorrectQuestions.forEach(item => {
                const div = document.createElement('div');
                div.className = 'list-group-item bg-transparent border-bottom';

                let correctInfo = '';
                if (item.correctName) {
                    correctInfo = `<div class="mt-1"><span class="badge bg-success bg-opacity-10 text-success">正解</span> <span class="fw-bold">${item.correctName}</span></div>`;
                }

                let explanation = '';
                if (item.explanation) {
                    explanation = `<div class="mt-1 small text-muted"><i class="fas fa-lightbulb text-warning me-1"></i>${item.explanation}</div>`;
                }

                div.innerHTML = `
                    <div class="fw-bold text-dark">${item.question}</div>
                    ${correctInfo}
                    ${explanation}
                `;
                wrongList.appendChild(div);
            });
            wrongSection.style.display = 'block';
        } else {
            wrongSection.style.display = 'none';
        }

        // Show Overlay (explicitly set flex to use flex utilities)
        document.getElementById('resultOverlay').style.display = 'flex';
    }

    // Toggle Labels Removed

    // Helper: Shuffle Array
    function shuffle(array) {
        let currentIndex = array.length, randomIndex;
        while (currentIndex != 0) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex--;
            [array[currentIndex], array[randomIndex]] = [
                array[randomIndex], array[currentIndex]];
        }
        return array;
    }

    // Helper: Audio (Placeholder)
    function playAudio(type) {
        // Implement audio if available
    }

    // Zoom/Pan Implementation
    function calculateFitState() {
        const img = document.getElementById('gameMapImage');
        const container = document.getElementById('gameArea');

        if (!img.naturalWidth) return null;

        const containerW = container.clientWidth;
        const containerH = container.clientHeight;
        const imgW = img.naturalWidth;
        const imgH = img.naturalHeight;

        // Calculate scale to "contain" the image
        // Use 0.95 factor to leave a small margin
        const scaleX = (containerW * 0.95) / imgW;
        const scaleY = (containerH * 0.95) / imgH;
        const targetScale = Math.min(scaleX, scaleY); // Fit entirely visible

        // Initial centering
        // Because transform-origin is 0 0, we calculate the top-left offset
        const scaledW = imgW * targetScale;
        const scaledH = imgH * targetScale;

        const targetPointX = (containerW - scaledW) / 2;
        const targetPointY = (containerH - scaledH) / 2;

        return {
            scale: targetScale,
            pointX: targetPointX,
            pointY: targetPointY
        };
    }

    function fitMapToScreen() {
        const state = calculateFitState();
        if (!state) return;

        scale = state.scale;
        pointX = state.pointX;
        pointY = state.pointY;

        // Reset pan limits or start positions if needed
        startX = 0;
        startY = 0;

        setTransform();
    }

    function initPanZoom() {
        // Mouse Events
        gameArea.onmousedown = function (e) {
            e.preventDefault();
            startX = e.clientX - pointX;
            startY = e.clientY - pointY;
            panning = true;
            gameArea.style.cursor = 'grabbing';
        };

        gameArea.onmouseup = function (e) {
            panning = false;
            gameArea.style.cursor = 'grab';
        };

        gameArea.onmousemove = function (e) {
            e.preventDefault();
            if (!panning) return;
            pointX = e.clientX - startX;
            pointY = e.clientY - startY;
            setTransform();
        };

        gameArea.onwheel = function (e) {
            e.preventDefault();
            const xs = (e.clientX - pointX) / scale,
                ys = (e.clientY - pointY) / scale,
                delta = -e.deltaY;

            (delta > 0) ? (scale *= 1.2) : (scale /= 1.2);

            if (scale < 0.1) scale = 0.1;
            if (scale > 5) scale = 5;

            pointX = e.clientX - xs * scale;
            pointY = e.clientY - ys * scale;

            setTransform();
        };

        // Touch Events (Mobile Support)
        gameArea.addEventListener('touchstart', handleTouchStart, { passive: false });
        gameArea.addEventListener('touchmove', handleTouchMove, { passive: false });
        gameArea.addEventListener('touchend', handleTouchEnd);
    }

    // Touch State
    let lastTouchX = 0;
    let lastTouchY = 0;
    let initialPinchDistance = null;
    let initialScale = 1;

    function handleTouchStart(e) {
        if (e.touches.length === 1) {
            // Single touch - Pan
            const touch = e.touches[0];
            startX = touch.clientX - pointX;
            startY = touch.clientY - pointY;
            panning = true;
        } else if (e.touches.length === 2) {
            // key: Multi touch - Pinch Zoom
            panning = false;
            initialPinchDistance = getDistance(e.touches);
            initialScale = scale;
        }
    }

    function handleTouchMove(e) {
        e.preventDefault(); // Prevent scrolling

        if (e.touches.length === 1 && panning) {
            // Pan
            const touch = e.touches[0];
            pointX = touch.clientX - startX;
            pointY = touch.clientY - startY;
            setTransform();
        } else if (e.touches.length === 2 && initialPinchDistance) {
            // Pinch Zoom
            const currentDistance = getDistance(e.touches);
            const zoomFactor = currentDistance / initialPinchDistance;

            // Calculate center point between two fingers
            const center = getCenter(e.touches);
            const cx = center.x;
            const cy = center.y;

            // Calculate world coordinates of that center
            const wx = (cx - pointX) / scale;
            const wy = (cy - pointY) / scale;

            // Apply new scale
            let newScale = initialScale * zoomFactor;

            // Limits
            if (newScale < 0.1) newScale = 0.1;
            if (newScale > 5) newScale = 5;

            scale = newScale;

            // Adjust pointX/Y to keep world center at screen center
            pointX = cx - wx * scale;
            pointY = cy - wy * scale;

            setTransform();
        }
    }

    function handleTouchEnd(e) {
        if (e.touches.length < 2) {
            initialPinchDistance = null;
        }
        if (e.touches.length === 0) {
            panning = false;
        }
    }

    // Helper: Distance between two touch points
    function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    // Helper: Center point between two touch points
    function getCenter(touches) {
        return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
        };
    }

    function setTransform() {
        mapWrapper.style.transform = "translate(" + pointX + "px, " + pointY + "px) scale(" + scale + ")";

        // Counter-scale pins
        const invScale = 1 / scale;
        document.querySelectorAll('.game-pin').forEach(pin => {
            pin.style.transform = `scale(${invScale})`;
        });
    }

    function zoomMap(factor) {
        const container = document.getElementById('gameArea');
        const cx = container.clientWidth / 2;
        const cy = container.clientHeight / 2;

        // Calculate world coordinates of center
        const wx = (cx - pointX) / scale;
        const wy = (cy - pointY) / scale;

        scale *= factor;

        // Limits
        if (scale < 0.1) scale = 0.1;
        if (scale > 5) scale = 5;

        // Adjust pointX/Y to keep world center at screen center
        pointX = cx - wx * scale;
        pointY = cy - wy * scale;

        setTransform();
    }
</script>

<!-- Result Overlay -->
<div id="resultOverlay" class="position-absolute top-0 start-0 w-100 h-100 justify-content-center align-items-center"
    style="display: none; z-index: 10000; background-color: rgba(255, 255, 255, 0.95); backdrop-filter: blur(5px);">

    <div class="card border-0 shadow-lg rounded-4 overflow-hidden"
        style="max-width: 600px; width: 90%; max-height: 90vh; display: flex; flex-direction: column;">
        <div class="card-header bg-primary text-white text-center py-4 border-0">
            <h2 class="fw-bold mb-0"><i class="fas fa-flag-checkered me-2"></i> 結果発表</h2>
        </div>

        <div class="card-body p-4 p-md-5 text-center overflow-auto" style="flex: 1;">

            <!-- Result Icon/Message -->
            <div class="mb-4">
                <i id="resultIcon" class="fas fa-crown fa-4x text-warning mb-3" style="display: none;"></i>
                <h3 id="resultMessage" class="fw-bold text-dark"></h3>
            </div>

            <!-- Score Display -->
            <div class="d-flex justify-content-center align-items-baseline mb-4">
                <span id="resultScore" class="display-1 fw-bold text-primary" style="line-height: 1;">0</span>
                <span class="fs-2 text-muted mx-2">/</span>
                <span id="resultTotal" class="fs-2 text-muted">0</span>
            </div>

            <p id="resultPercentage" class="text-muted mb-4 fs-5"></p>

            <!-- Wrong Answers Section -->
            <div id="wrongAnswersSection" class="text-start mb-4 bg-light rounded-3 p-3" style="display: none;">
                <h5 class="text-danger fw-bold mb-3 border-bottom pb-2">
                    <i class="fas fa-exclamation-triangle me-2"></i> 復習しよう
                </h5>
                <div id="wrongAnswersList" class="list-group list-group-flush bg-transparent">
                    <!-- Wrong answers injected here -->
                </div>
            </div>

            <!-- Buttons -->
            <div class="d-grid gap-3 d-sm-flex justify-content-center mt-auto">
                <button class="btn btn-primary btn-lg rounded-pill px-5 shadow-sm hover-shadow"
                    onclick="location.reload()">
                    <i class="fas fa-redo me-2"></i>
                </button>
                <a href="{{ url_for('map_quiz_index') }}"
                    class="btn btn-outline-secondary btn-lg rounded-pill px-5 shadow-sm">
                    <i class="fas fa-map me-2"></i> 地図選択
                </a>
            </div>
        </div>
    </div>
</div>

<style>
    /* Override base container to allow full screen */
    body>.container {
        max-width: none !important;
        padding: 0 !important;
        margin: 0 !important;
        width: 100% !important;
    }

    .disable-clicks {
        pointer-events: none;
    }
</style>

{% block footer %}{% endblock %}
{% block info_icon %}{% endblock %}
{% endblock %}